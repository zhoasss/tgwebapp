# üîç –ê–Ω–∞–ª–∏–∑ –∫–æ–¥–∞ –∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —É–ª—É—á—à–µ–Ω–∏—é

**–î–∞—Ç–∞ –∞–Ω–∞–ª–∏–∑–∞:** 2025-11-22  
**–ü—Ä–æ–µ–∫—Ç:** Telegram Mini App - –õ–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞–ø–∏—Å—è–º–∏

---

## üìä –û–±—â–∞—è –æ—Ü–µ–Ω–∫–∞ –ø—Ä–æ–µ–∫—Ç–∞

### ‚úÖ –°–∏–ª—å–Ω—ã–µ —Å—Ç–æ—Ä–æ–Ω—ã

1. **–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ FSD (Feature-Sliced Design)**
   - –ß–µ—Ç–∫–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –Ω–∞ —Å–ª–æ–∏ (app, pages, widgets, entities, shared)
   - –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –º–µ–∂–¥—É —Å–ª–æ—è–º–∏
   - –ú–æ–¥—É–ª—å–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –æ–±–ª–µ–≥—á–∞–µ—Ç –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ

2. **Docker-–∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞**
   - –ü–æ–ª–Ω–∞—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∏–∑–∞—Ü–∏—è (backend, frontend, bot, db)
   - Health checks –¥–ª—è –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
   - –û—Ç–¥–µ–ª—å–Ω—ã–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –¥–ª—è dev/prod
   - –£–¥–æ–±–Ω—ã–π Makefile —Å –∫–æ–º–∞–Ω–¥–∞–º–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è

3. **Backend (Python/FastAPI)**
   - –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π —Å—Ç–µ–∫ (FastAPI 0.115.6, SQLAlchemy 2.0.36)
   - –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Ä–∞–±–æ—Ç–∞ —Å –ë–î (aiosqlite)
   - JWT-–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —Å refresh tokens
   - Telegram WebApp authentication
   - –ú–æ–¥—É–ª—å–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ API endpoints

4. **Frontend**
   - Vanilla JS –±–µ–∑ –ª–∏—à–Ω–∏—Ö –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
   - –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Telegram WebApp SDK
   - –ì–ª–æ–±–∞–ª—å–Ω—ã–π loader –¥–ª—è UX
   - –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–æ–≤
   - –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π –¥–∏–∑–∞–π–Ω

5. **–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è**
   - –ü–æ–¥—Ä–æ–±–Ω—ã–π README —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã
   - DB_COMMANDS.md —Å –ø–æ–ª–µ–∑–Ω—ã–º–∏ –∫–æ–º–∞–Ω–¥–∞–º–∏
   - –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –≤ –∫–æ–¥–µ

---

## üö® –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã

### 1. **–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö**

**–ü—Ä–æ–±–ª–µ–º–∞:** –í `docker-compose.yml` –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è SQLite —Å –ø—Ä–∞–≤–∞–º–∏ `666` (—á—Ç–µ–Ω–∏–µ/–∑–∞–ø–∏—Å—å –¥–ª—è –≤—Å–µ—Ö)

```yaml
# docker-compose.yml:78
command: sh -c "touch /app/database.db && chmod 666 /app/database.db && tail -f /dev/null"
```

**–†–∏—Å–∫–∏:**
- –õ—é–±–æ–π –ø—Ä–æ—Ü–µ—Å—Å –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–µ –º–æ–∂–µ—Ç —á–∏—Ç–∞—Ç—å/–∏–∑–º–µ–Ω—è—Ç—å –ë–î
- –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è —É—Ç–µ—á–∫–∞ –¥–∞–Ω–Ω—ã—Ö

**–†–µ—à–µ–Ω–∏–µ:**
```yaml
command: sh -c "touch /app/database.db && chmod 660 /app/database.db && tail -f /dev/null"
user: "1000:1000"  # –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
```

### 2. **–û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –º–∏–≥—Ä–∞—Ü–∏–π –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö**

**–ü—Ä–æ–±–ª–µ–º–∞:** –í –ø—Ä–æ–µ–∫—Ç–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω Alembic, –Ω–æ –Ω–µ—Ç –ø–∞–ø–∫–∏ —Å –º–∏–≥—Ä–∞—Ü–∏—è–º–∏

**–†–∏—Å–∫–∏:**
- –°–ª–æ–∂–Ω–æ—Å—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ö–µ–º—ã –ë–î –≤ production
- –ù–µ–≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –æ—Ç–∫–∞—Ç–∞ –∏–∑–º–µ–Ω–µ–Ω–∏–π
- –ü–æ—Ç–µ—Ä—è –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã

**–†–µ—à–µ–Ω–∏–µ:**
```bash
# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å Alembic
cd backend
alembic init alembic

# –°–æ–∑–¥–∞—Ç—å –ø–µ—Ä–≤—É—é –º–∏–≥—Ä–∞—Ü–∏—é
alembic revision --autogenerate -m "Initial migration"

# –ü—Ä–∏–º–µ–Ω–∏—Ç—å –º–∏–≥—Ä–∞—Ü–∏–∏
alembic upgrade head
```

### 3. **–•–∞—Ä–¥–∫–æ–¥ –≤ –∫–æ–¥–µ**

**–ü—Ä–∏–º–µ—Ä—ã:**
```python
# api_server.py:117
"timestamp": "2025-01-01T12:00:00Z",  # –•–∞—Ä–¥–∫–æ–¥ –¥–∞—Ç—ã
```

**–†–µ—à–µ–Ω–∏–µ:**
```python
from datetime import datetime
"timestamp": datetime.utcnow().isoformat() + "Z"
```

---

## ‚ö†Ô∏è –í–∞–∂–Ω—ã–µ —É–ª—É—á—à–µ–Ω–∏—è

### 1. **–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è**

#### Backend

**–ü—Ä–æ–±–ª–µ–º–∞:** TODO –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ —É–∫–∞–∑—ã–≤–∞—é—Ç –Ω–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â—É—é —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å

```python
# appointments.py:199
# TODO: –î–æ–±–∞–≤–∏—Ç—å –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—É—é –ª–æ–≥–∏–∫—É –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π

# clients.py:356
# TODO: –î–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π –ø–µ—Ä–µ–¥ —É–¥–∞–ª–µ–Ω–∏–µ–º

# services.py:330
# TODO: –î–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π –ø–µ—Ä–µ–¥ —É–¥–∞–ª–µ–Ω–∏–µ–º

# schedule.py:260
# TODO: –£—á–∏—Ç—ã–≤–∞—Ç—å –ø—Ä–æ–¥–æ–ª–∂–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —É—Å–ª—É–≥ –∏ –ø–µ—Ä–µ—Ä—ã–≤—ã
```

**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:**

1. **–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π –∑–∞–ø–∏—Å–µ–π:**
```python
async def check_appointment_overlap(
    session: AsyncSession,
    user_id: int,
    appointment_date: datetime,
    duration_minutes: int,
    exclude_id: int = None
) -> bool:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –Ω–µ –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç—Å—è –ª–∏ –Ω–æ–≤–∞—è –∑–∞–ø–∏—Å—å —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º–∏"""
    end_time = appointment_date + timedelta(minutes=duration_minutes)
    
    query = select(Appointment).where(
        Appointment.user_id == user_id,
        Appointment.status.in_(['pending', 'confirmed']),
        or_(
            # –ù–æ–≤–∞—è –∑–∞–ø–∏—Å—å –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –≤–æ –≤—Ä–µ–º—è —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π
            and_(
                Appointment.appointment_date <= appointment_date,
                Appointment.appointment_date + timedelta(minutes=Appointment.duration_minutes) > appointment_date
            ),
            # –ù–æ–≤–∞—è –∑–∞–ø–∏—Å—å –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è –≤–æ –≤—Ä–µ–º—è —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π
            and_(
                Appointment.appointment_date < end_time,
                Appointment.appointment_date + timedelta(minutes=Appointment.duration_minutes) >= end_time
            ),
            # –ù–æ–≤–∞—è –∑–∞–ø–∏—Å—å –ø–æ–ª–Ω–æ—Å—Ç—å—é –æ—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é
            and_(
                Appointment.appointment_date >= appointment_date,
                Appointment.appointment_date + timedelta(minutes=Appointment.duration_minutes) <= end_time
            )
        )
    )
    
    if exclude_id:
        query = query.where(Appointment.id != exclude_id)
    
    result = await session.execute(query)
    overlapping = result.scalars().first()
    
    return overlapping is not None
```

2. **–ö–∞—Å–∫–∞–¥–Ω–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π:**
```python
async def delete_service_safe(service_id: int, user_id: int, session: AsyncSession):
    """–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ —É—Å–ª—É–≥–∏ —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π"""
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–ø–∏—Å–∏
    active_appointments = await session.execute(
        select(Appointment).where(
            Appointment.service_id == service_id,
            Appointment.status.in_(['pending', 'confirmed'])
        )
    )
    
    if active_appointments.scalars().first():
        raise HTTPException(
            status_code=400,
            detail="–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å —É—Å–ª—É–≥—É —Å –∞–∫—Ç–∏–≤–Ω—ã–º–∏ –∑–∞–ø–∏—Å—è–º–∏. –°–Ω–∞—á–∞–ª–∞ –æ—Ç–º–µ–Ω–∏—Ç–µ –∏–ª–∏ –∑–∞–≤–µ—Ä—à–∏—Ç–µ –≤—Å–µ –∑–∞–ø–∏—Å–∏."
        )
    
    # –£–¥–∞–ª—è–µ–º —É—Å–ª—É–≥—É
    await session.execute(
        delete(Service).where(Service.id == service_id, Service.user_id == user_id)
    )
    await session.commit()
```

#### Frontend

**–ü—Ä–æ–±–ª–µ–º–∞:** –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è —Ñ–æ—Ä–º

**–†–µ—à–µ–Ω–∏–µ:** –î–æ–±–∞–≤–∏—Ç—å –≤–∞–ª–∏–¥–∞—Ü–∏—é –Ω–∞ –∫–ª–∏–µ–Ω—Ç–µ –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π:

```javascript
// –ü—Ä–∏–º–µ—Ä –¥–ª—è services.js
function validateServiceForm(formData) {
    const errors = [];
    
    if (!formData.name || formData.name.trim().length < 2) {
        errors.push('–ù–∞–∑–≤–∞–Ω–∏–µ —É—Å–ª—É–≥–∏ –¥–æ–ª–∂–Ω–æ —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 2 —Å–∏–º–≤–æ–ª–∞');
    }
    
    if (formData.price <= 0) {
        errors.push('–¶–µ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –±–æ–ª—å—à–µ 0');
    }
    
    if (formData.duration_minutes < 5 || formData.duration_minutes > 480) {
        errors.push('–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—Ç 5 –¥–æ 480 –º–∏–Ω—É—Ç');
    }
    
    return errors;
}

// –í handleFormSubmit
const errors = validateServiceForm(formData);
if (errors.length > 0) {
    showNotification(errors.join('\n'), 'error');
    return;
}
```

### 2. **–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥**

**–ü—Ä–æ–±–ª–µ–º–∞:** –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –º–µ—Ç—Ä–∏–∫–∏

**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:**

1. **–°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ:**
```python
# –î–æ–±–∞–≤–∏—Ç—å –≤ backend/requirements.txt
python-json-logger==2.0.7

# –û–±–Ω–æ–≤–∏—Ç—å shared/logger/setup.py
from pythonjsonlogger import jsonlogger

def setup_logging(log_file, max_bytes, backup_count):
    logHandler = RotatingFileHandler(
        log_file,
        maxBytes=max_bytes,
        backupCount=backup_count
    )
    
    formatter = jsonlogger.JsonFormatter(
        '%(timestamp)s %(level)s %(name)s %(message)s',
        timestamp=True
    )
    
    logHandler.setFormatter(formatter)
    # ...
```

2. **–î–æ–±–∞–≤–∏—Ç—å endpoint –¥–ª—è –º–µ—Ç—Ä–∏–∫:**
```python
# api_server.py
from datetime import datetime
import psutil

@app.get("/api/metrics")
async def get_metrics(session: AsyncSession = Depends(get_session)):
    """–ú–µ—Ç—Ä–∏–∫–∏ —Å–∏—Å—Ç–µ–º—ã –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞"""
    # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ë–î
    users_count = await session.execute(select(func.count(User.id)))
    services_count = await session.execute(select(func.count(Service.id)))
    appointments_count = await session.execute(select(func.count(Appointment.id)))
    
    return {
        "timestamp": datetime.utcnow().isoformat(),
        "database": {
            "users": users_count.scalar(),
            "services": services_count.scalar(),
            "appointments": appointments_count.scalar()
        },
        "system": {
            "cpu_percent": psutil.cpu_percent(),
            "memory_percent": psutil.virtual_memory().percent,
            "disk_percent": psutil.disk_usage('/').percent
        }
    }
```

### 3. **–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ**

**–ü—Ä–æ–±–ª–µ–º–∞:** –ü–æ–ª–Ω–æ–µ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ —Ç–µ—Å—Ç–æ–≤

**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:**

1. **Backend —Ç–µ—Å—Ç—ã:**
```python
# backend/tests/test_appointments.py
import pytest
from httpx import AsyncClient
from datetime import datetime, timedelta

@pytest.mark.asyncio
async def test_create_appointment(client: AsyncClient, auth_headers):
    """–¢–µ—Å—Ç —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–ø–∏—Å–∏"""
    appointment_data = {
        "service_id": 1,
        "client_id": 1,
        "appointment_date": (datetime.now() + timedelta(days=1)).isoformat(),
        "notes": "Test appointment"
    }
    
    response = await client.post(
        "/api/appointments",
        json=appointment_data,
        headers=auth_headers
    )
    
    assert response.status_code == 201
    data = response.json()
    assert data["notes"] == "Test appointment"

@pytest.mark.asyncio
async def test_appointment_overlap(client: AsyncClient, auth_headers):
    """–¢–µ—Å—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –∑–∞–ø–∏—Å–µ–π"""
    # –°–æ–∑–¥–∞–µ–º –ø–µ—Ä–≤—É—é –∑–∞–ø–∏—Å—å
    time1 = datetime.now() + timedelta(days=1, hours=10)
    await client.post("/api/appointments", json={
        "service_id": 1,
        "client_id": 1,
        "appointment_date": time1.isoformat()
    }, headers=auth_headers)
    
    # –ü—ã—Ç–∞–µ–º—Å—è —Å–æ–∑–¥–∞—Ç—å –ø–µ—Ä–µ—Å–µ–∫–∞—é—â—É—é—Å—è –∑–∞–ø–∏—Å—å
    time2 = time1 + timedelta(minutes=15)
    response = await client.post("/api/appointments", json={
        "service_id": 1,
        "client_id": 2,
        "appointment_date": time2.isoformat()
    }, headers=auth_headers)
    
    assert response.status_code == 400
    assert "–ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç—Å—è" in response.json()["detail"].lower()
```

2. **Frontend —Ç–µ—Å—Ç—ã (Jest):**
```javascript
// frontend/tests/api-client.test.js
import { apiClient } from '../src/shared/lib/api-client.js';

describe('ApiClient', () => {
    test('should add auth header', async () => {
        localStorage.setItem('access_token', 'test_token');
        
        const mockFetch = jest.fn(() => 
            Promise.resolve({
                ok: true,
                json: () => Promise.resolve({ data: 'test' })
            })
        );
        global.fetch = mockFetch;
        
        await apiClient.get('/test');
        
        expect(mockFetch).toHaveBeenCalledWith(
            expect.any(String),
            expect.objectContaining({
                headers: expect.objectContaining({
                    'Authorization': 'Bearer test_token'
                })
            })
        );
    });
});
```

### 4. **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å**

**–ü—Ä–æ–±–ª–µ–º—ã:**

1. **N+1 –∑–∞–ø—Ä–æ—Å—ã –≤ –ë–î**
```python
# appointments.py - –∑–∞–≥—Ä—É–∑–∫–∞ —Å–≤—è–∑–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
appointments = result.scalars().all()
# –î–ª—è –∫–∞–∂–¥–æ–π –∑–∞–ø–∏—Å–∏ –¥–µ–ª–∞–µ—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω—ã–π –∑–∞–ø—Ä–æ—Å –¥–ª—è service –∏ client
```

**–†–µ—à–µ–Ω–∏–µ:**
```python
from sqlalchemy.orm import selectinload

query = select(Appointment).options(
    selectinload(Appointment.service),
    selectinload(Appointment.client)
).where(Appointment.user_id == user_id)
```

2. **–û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è**

**–†–µ—à–µ–Ω–∏–µ:** –î–æ–±–∞–≤–∏—Ç—å Redis –¥–ª—è –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è
```python
# requirements.txt
redis==5.0.1
aioredis==2.0.1

# shared/cache/redis_client.py
import aioredis
from functools import wraps
import json

redis_client = None

async def init_redis():
    global redis_client
    redis_client = await aioredis.from_url(
        "redis://localhost",
        encoding="utf-8",
        decode_responses=True
    )

def cache(ttl: int = 300):
    """–î–µ–∫–æ—Ä–∞—Ç–æ—Ä –¥–ª—è –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤"""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # –°–æ–∑–¥–∞–µ–º –∫–ª—é—á –∫—ç—à–∞
            cache_key = f"{func.__name__}:{str(args)}:{str(kwargs)}"
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
            cached = await redis_client.get(cache_key)
            if cached:
                return json.loads(cached)
            
            # –í—ã–ø–æ–ª–Ω—è–µ–º —Ñ—É–Ω–∫—Ü–∏—é
            result = await func(*args, **kwargs)
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∫—ç—à
            await redis_client.setex(
                cache_key,
                ttl,
                json.dumps(result)
            )
            
            return result
        return wrapper
    return decorator

# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
@router.get("/services")
@cache(ttl=600)  # –ö—ç—à –Ω–∞ 10 –º–∏–Ω—É—Ç
async def get_services(...):
    ...
```

3. **–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è frontend**

```javascript
// –î–æ–±–∞–≤–∏—Ç—å debounce –¥–ª—è –ø–æ–∏—Å–∫–∞
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
const searchInput = document.getElementById('search');
searchInput.addEventListener('input', debounce(async (e) => {
    const results = await searchClients(e.target.value);
    renderResults(results);
}, 300));
```

---

## üí° –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–µ –Ω–æ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏

### 1. **–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è**

**Telegram Bot —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:**
```python
# features/notifications/telegram_notifier.py
from telegram import Bot

class TelegramNotifier:
    def __init__(self, bot_token: str):
        self.bot = Bot(token=bot_token)
    
    async def send_appointment_reminder(self, user_telegram_id: int, appointment: Appointment):
        """–û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –æ –∑–∞–ø–∏—Å–∏"""
        message = (
            f"üîî –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –æ –∑–∞–ø–∏—Å–∏\n\n"
            f"–ö–ª–∏–µ–Ω—Ç: {appointment.client.first_name}\n"
            f"–£—Å–ª—É–≥–∞: {appointment.service.name}\n"
            f"–í—Ä–µ–º—è: {appointment.appointment_date.strftime('%d.%m.%Y %H:%M')}\n"
            f"–¶–µ–Ω–∞: {appointment.price} ‚ÇΩ"
        )
        
        await self.bot.send_message(
            chat_id=user_telegram_id,
            text=message
        )
    
    async def send_new_appointment_notification(self, user_telegram_id: int, appointment: Appointment):
        """–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –Ω–æ–≤–æ–π –∑–∞–ø–∏—Å–∏"""
        message = f"‚úÖ –ù–æ–≤–∞—è –∑–∞–ø–∏—Å—å –æ—Ç {appointment.client.first_name} –Ω–∞ {appointment.appointment_date.strftime('%d.%m.%Y %H:%M')}"
        
        await self.bot.send_message(
            chat_id=user_telegram_id,
            text=message
        )

# –î–æ–±–∞–≤–∏—Ç—å –≤ appointments.py
@router.post("/appointments")
async def create_appointment(...):
    # ... —Å–æ–∑–¥–∞–Ω–∏–µ –∑–∞–ø–∏—Å–∏ ...
    
    # –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
    notifier = TelegramNotifier(config.bot_token)
    await notifier.send_new_appointment_notification(
        user.telegram_id,
        new_appointment
    )
```

**–ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π:**
```python
# features/scheduler/appointment_reminders.py
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from datetime import datetime, timedelta

scheduler = AsyncIOScheduler()

async def check_upcoming_appointments():
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∑–∞–ø–∏—Å–∏ –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π –¥–µ–Ω—å –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è"""
    tomorrow = datetime.now() + timedelta(days=1)
    
    async with get_session() as session:
        appointments = await session.execute(
            select(Appointment).where(
                Appointment.appointment_date >= tomorrow.replace(hour=0, minute=0),
                Appointment.appointment_date < tomorrow.replace(hour=23, minute=59),
                Appointment.status == 'confirmed'
            )
        )
        
        notifier = TelegramNotifier(config.bot_token)
        
        for appointment in appointments.scalars():
            await notifier.send_appointment_reminder(
                appointment.user.telegram_id,
                appointment
            )

# –ó–∞–ø—É—Å–∫–∞—Ç—å –∫–∞–∂–¥—ã–π –¥–µ–Ω—å –≤ 18:00
scheduler.add_job(check_upcoming_appointments, 'cron', hour=18)
scheduler.start()
```

### 2. **–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏ –∞–Ω–∞–ª–∏—Ç–∏–∫–∞**

```python
# features/api/analytics.py
from fastapi import APIRouter
from sqlalchemy import func, extract
from datetime import datetime, timedelta

router = APIRouter(prefix="/analytics", tags=["analytics"])

@router.get("/dashboard")
async def get_dashboard_stats(
    current_user: dict = Depends(get_current_user),
    session: AsyncSession = Depends(get_session)
):
    """–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –¥–ª—è –¥–∞—à–±–æ—Ä–¥–∞"""
    user_id = current_user["user_id"]
    
    # –ó–∞–ø–∏—Å–∏ –∑–∞ —Ç–µ–∫—É—â–∏–π –º–µ—Å—è—Ü
    current_month = datetime.now().replace(day=1, hour=0, minute=0, second=0)
    next_month = (current_month + timedelta(days=32)).replace(day=1)
    
    # –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–ø–∏—Å–µ–π –ø–æ —Å—Ç–∞—Ç—É—Å–∞–º
    appointments_stats = await session.execute(
        select(
            Appointment.status,
            func.count(Appointment.id).label('count')
        ).where(
            Appointment.user_id == user_id,
            Appointment.appointment_date >= current_month,
            Appointment.appointment_date < next_month
        ).group_by(Appointment.status)
    )
    
    # –î–æ—Ö–æ–¥ –∑–∞ –º–µ—Å—è—Ü
    revenue = await session.execute(
        select(func.sum(Appointment.price)).where(
            Appointment.user_id == user_id,
            Appointment.status == 'completed',
            Appointment.appointment_date >= current_month,
            Appointment.appointment_date < next_month
        )
    )
    
    # –¢–æ–ø —É—Å–ª—É–≥
    top_services = await session.execute(
        select(
            Service.name,
            func.count(Appointment.id).label('bookings')
        ).join(Appointment).where(
            Service.user_id == user_id,
            Appointment.appointment_date >= current_month,
            Appointment.appointment_date < next_month
        ).group_by(Service.id).order_by(func.count(Appointment.id).desc()).limit(5)
    )
    
    return {
        "period": {
            "start": current_month.isoformat(),
            "end": next_month.isoformat()
        },
        "appointments_by_status": {
            row.status: row.count 
            for row in appointments_stats
        },
        "revenue": revenue.scalar() or 0,
        "top_services": [
            {"name": row.name, "bookings": row.bookings}
            for row in top_services
        ]
    }

@router.get("/revenue-chart")
async def get_revenue_chart(
    period: str = "month",  # month, quarter, year
    current_user: dict = Depends(get_current_user),
    session: AsyncSession = Depends(get_session)
):
    """–î–∞–Ω–Ω—ã–µ –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–∞ –¥–æ—Ö–æ–¥–æ–≤"""
    user_id = current_user["user_id"]
    
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–µ—Ä–∏–æ–¥
    if period == "month":
        days = 30
        group_by = extract('day', Appointment.appointment_date)
    elif period == "quarter":
        days = 90
        group_by = extract('week', Appointment.appointment_date)
    else:  # year
        days = 365
        group_by = extract('month', Appointment.appointment_date)
    
    start_date = datetime.now() - timedelta(days=days)
    
    revenue_data = await session.execute(
        select(
            group_by.label('period'),
            func.sum(Appointment.price).label('revenue')
        ).where(
            Appointment.user_id == user_id,
            Appointment.status == 'completed',
            Appointment.appointment_date >= start_date
        ).group_by('period').order_by('period')
    )
    
    return {
        "period": period,
        "data": [
            {"period": row.period, "revenue": row.revenue}
            for row in revenue_data
        ]
    }
```

**Frontend –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏:**
```javascript
// pages/analytics/analytics.js
import { apiClient } from '../../shared/lib/api-client.js';

async function loadDashboard() {
    const data = await apiClient.get('/api/analytics/dashboard');
    
    // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
    document.getElementById('total-revenue').textContent = 
        `${data.revenue.toLocaleString()} ‚ÇΩ`;
    
    document.getElementById('pending-count').textContent = 
        data.appointments_by_status.pending || 0;
    
    document.getElementById('confirmed-count').textContent = 
        data.appointments_by_status.confirmed || 0;
    
    // –¢–æ–ø —É—Å–ª—É–≥
    const topServicesList = document.getElementById('top-services');
    topServicesList.innerHTML = data.top_services.map(service => `
        <div class="service-stat">
            <span>${service.name}</span>
            <span class="badge">${service.bookings}</span>
        </div>
    `).join('');
}

async function loadRevenueChart(period = 'month') {
    const data = await apiClient.get(`/api/analytics/revenue-chart?period=${period}`);
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º Chart.js –∏–ª–∏ –¥—Ä—É–≥—É—é –±–∏–±–ª–∏–æ—Ç–µ–∫—É
    renderChart(data);
}
```

### 3. **–≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö**

```python
# features/api/export.py
from fastapi import APIRouter
from fastapi.responses import StreamingResponse
import csv
import io

router = APIRouter(prefix="/export", tags=["export"])

@router.get("/appointments/csv")
async def export_appointments_csv(
    date_from: Optional[date] = None,
    date_to: Optional[date] = None,
    current_user: dict = Depends(get_current_user),
    session: AsyncSession = Depends(get_session)
):
    """–≠–∫—Å–ø–æ—Ä—Ç –∑–∞–ø–∏—Å–µ–π –≤ CSV"""
    user_id = current_user["user_id"]
    
    query = select(Appointment).options(
        selectinload(Appointment.service),
        selectinload(Appointment.client)
    ).where(Appointment.user_id == user_id)
    
    if date_from:
        query = query.where(Appointment.appointment_date >= date_from)
    if date_to:
        query = query.where(Appointment.appointment_date <= date_to)
    
    result = await session.execute(query)
    appointments = result.scalars().all()
    
    # –°–æ–∑–¥–∞–µ–º CSV
    output = io.StringIO()
    writer = csv.writer(output)
    
    # –ó–∞–≥–æ–ª–æ–≤–∫–∏
    writer.writerow([
        'ID', '–î–∞—Ç–∞', '–í—Ä–µ–º—è', '–ö–ª–∏–µ–Ω—Ç', '–¢–µ–ª–µ—Ñ–æ–Ω', 
        '–£—Å–ª—É–≥–∞', '–¶–µ–Ω–∞', '–°—Ç–∞—Ç—É—Å', '–ó–∞–º–µ—Ç–∫–∏'
    ])
    
    # –î–∞–Ω–Ω—ã–µ
    for apt in appointments:
        writer.writerow([
            apt.id,
            apt.appointment_date.strftime('%d.%m.%Y'),
            apt.appointment_date.strftime('%H:%M'),
            f"{apt.client.first_name} {apt.client.last_name}",
            apt.client.phone,
            apt.service.name,
            apt.price,
            apt.status,
            apt.notes or ''
        ])
    
    output.seek(0)
    
    return StreamingResponse(
        iter([output.getvalue()]),
        media_type="text/csv",
        headers={
            "Content-Disposition": f"attachment; filename=appointments_{datetime.now().strftime('%Y%m%d')}.csv"
        }
    )
```

### 4. **–ü–æ–∏—Å–∫ –∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è**

```python
# features/api/search.py
from fastapi import APIRouter, Query

router = APIRouter(prefix="/search", tags=["search"])

@router.get("/")
async def global_search(
    q: str = Query(..., min_length=2),
    current_user: dict = Depends(get_current_user),
    session: AsyncSession = Depends(get_session)
):
    """–ì–ª–æ–±–∞–ª—å–Ω—ã–π –ø–æ–∏—Å–∫ –ø–æ –∫–ª–∏–µ–Ω—Ç–∞–º, —É—Å–ª—É–≥–∞–º –∏ –∑–∞–ø–∏—Å—è–º"""
    user_id = current_user["user_id"]
    search_term = f"%{q}%"
    
    # –ü–æ–∏—Å–∫ –∫–ª–∏–µ–Ω—Ç–æ–≤
    clients = await session.execute(
        select(Client).where(
            Client.user_id == user_id,
            or_(
                Client.first_name.ilike(search_term),
                Client.last_name.ilike(search_term),
                Client.phone.ilike(search_term)
            )
        ).limit(10)
    )
    
    # –ü–æ–∏—Å–∫ —É—Å–ª—É–≥
    services = await session.execute(
        select(Service).where(
            Service.user_id == user_id,
            or_(
                Service.name.ilike(search_term),
                Service.description.ilike(search_term)
            )
        ).limit(10)
    )
    
    return {
        "query": q,
        "results": {
            "clients": [c.to_dict() for c in clients.scalars()],
            "services": [s.to_dict() for s in services.scalars()]
        }
    }
```

### 5. **–û–Ω–ª–∞–π–Ω-–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –∫–ª–∏–µ–Ω—Ç–æ–≤**

```python
# features/api/public_booking.py
from fastapi import APIRouter

router = APIRouter(prefix="/public", tags=["public"])

@router.get("/booking/{username}")
async def get_public_booking_page(
    username: str,
    session: AsyncSession = Depends(get_session)
):
    """–ü—É–±–ª–∏—á–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è"""
    user = await session.execute(
        select(User).where(User.username == username)
    )
    user = user.scalar_one_or_none()
    
    if not user:
        raise HTTPException(status_code=404, detail="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
    
    # –ü–æ–ª—É—á–∞–µ–º –¥–æ—Å—Ç—É–ø–Ω—ã–µ —É—Å–ª—É–≥–∏
    services = await session.execute(
        select(Service).where(Service.user_id == user.id)
    )
    
    # –ü–æ–ª—É—á–∞–µ–º —Ä–∞–±–æ—á–∏–µ —á–∞—Å—ã
    working_hours = await session.execute(
        select(WorkingHours).where(WorkingHours.user_id == user.id)
    )
    
    return {
        "business_name": user.business_name,
        "services": [s.to_dict() for s in services.scalars()],
        "working_hours": [wh.to_dict() for wh in working_hours.scalars()]
    }

@router.post("/booking/{username}/appointments")
async def create_public_appointment(
    username: str,
    appointment_data: dict,
    session: AsyncSession = Depends(get_session)
):
    """–°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–ø–∏—Å–∏ —á–µ—Ä–µ–∑ –ø—É–±–ª–∏—á–Ω—É—é —Ñ–æ—Ä–º—É"""
    # –ù–∞—Ö–æ–¥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    user = await session.execute(
        select(User).where(User.username == username)
    )
    user = user.scalar_one_or_none()
    
    # –°–æ–∑–¥–∞–µ–º –∏–ª–∏ –Ω–∞—Ö–æ–¥–∏–º –∫–ª–∏–µ–Ω—Ç–∞
    client = await session.execute(
        select(Client).where(
            Client.user_id == user.id,
            Client.phone == appointment_data['phone']
        )
    )
    client = client.scalar_one_or_none()
    
    if not client:
        client = Client(
            user_id=user.id,
            first_name=appointment_data['first_name'],
            phone=appointment_data['phone']
        )
        session.add(client)
        await session.flush()
    
    # –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å
    appointment = Appointment(
        user_id=user.id,
        service_id=appointment_data['service_id'],
        client_id=client.id,
        appointment_date=appointment_data['appointment_date'],
        status='pending'
    )
    
    session.add(appointment)
    await session.commit()
    
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤–ª–∞–¥–µ–ª—å—Ü—É
    notifier = TelegramNotifier(config.bot_token)
    await notifier.send_new_appointment_notification(user.telegram_id, appointment)
    
    return {"message": "–ó–∞–ø–∏—Å—å —Å–æ–∑–¥–∞–Ω–∞", "appointment_id": appointment.id}
```

---

## üîß –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ —É–ª—É—á—à–µ–Ω–∏—è

### 1. **CI/CD Pipeline**

–°–æ–∑–¥–∞—Ç—å `.github/workflows/ci.yml`:

```yaml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test-backend:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'
    
    - name: Install dependencies
      run: |
        cd backend
        pip install -r requirements.txt
        pip install pytest pytest-asyncio pytest-cov
    
    - name: Run tests
      run: |
        cd backend
        pytest --cov=src --cov-report=xml
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3

  test-frontend:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
    
    - name: Install dependencies
      run: |
        cd frontend
        npm install
    
    - name: Run tests
      run: |
        cd frontend
        npm test

  lint:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Lint Python
      run: |
        pip install flake8 black
        cd backend
        flake8 src
        black --check src
    
    - name: Lint JavaScript
      run: |
        cd frontend
        npm install
        npm run lint

  deploy:
    needs: [test-backend, test-frontend, lint]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Deploy to production
      run: |
        # SSH deploy script
        ssh user@server 'cd /app && git pull && docker-compose up -d --build'
```

### 2. **Environment Variables Management**

–£–ª—É—á—à–∏—Ç—å `backend/src/shared/config/env_loader.py`:

```python
from pydantic_settings import BaseSettings
from typing import Optional
from pathlib import Path

class Settings(BaseSettings):
    # App
    app_name: str = "Telegram Mini App"
    app_version: str = "2.0.0"
    environment: str = "development"
    debug: bool = False
    
    # Server
    host: str = "0.0.0.0"
    port: int = 8000
    reload: bool = False
    
    # Database
    database_url: str = "sqlite+aiosqlite:////app/data/database.db"
    
    # Security
    secret_key: str
    algorithm: str = "HS256"
    access_token_expire_minutes: int = 30
    refresh_token_expire_days: int = 7
    
    # Telegram
    bot_token: str
    web_app_url: str
    
    # CORS
    cors_origins: list[str] = ["*"]
    cors_allow_credentials: bool = True
    cors_allow_methods: list[str] = ["*"]
    cors_allow_headers: list[str] = ["*"]
    
    # Logging
    log_level: str = "INFO"
    log_file: Optional[str] = None
    log_max_bytes: int = 10485760  # 10MB
    log_backup_count: int = 5
    
    # Redis (optional)
    redis_url: Optional[str] = None
    
    # Email (optional)
    smtp_host: Optional[str] = None
    smtp_port: Optional[int] = None
    smtp_user: Optional[str] = None
    smtp_password: Optional[str] = None
    
    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"
        case_sensitive = False

config = Settings()
```

### 3. **Rate Limiting**

```python
# requirements.txt
slowapi==0.1.9

# api_server.py
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
@router.post("/appointments")
@limiter.limit("10/minute")
async def create_appointment(request: Request, ...):
    ...
```

### 4. **Database Connection Pooling**

```python
# shared/database/connection.py
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker

engine = create_async_engine(
    config.database_url,
    echo=config.debug,
    pool_size=20,  # –†–∞–∑–º–µ—Ä –ø—É–ª–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
    max_overflow=10,  # –ú–∞–∫—Å–∏–º—É–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
    pool_pre_ping=True,  # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π –ø–µ—Ä–µ–¥ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º
    pool_recycle=3600  # –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫–∞–∂–¥—ã–π —á–∞—Å
)
```

### 5. **API Versioning**

```python
# api_server.py
from fastapi import APIRouter

# API v1
api_v1 = APIRouter(prefix="/api/v1")
api_v1.include_router(profile_router, tags=["profiles"])
api_v1.include_router(services_router, tags=["services"])
# ...

# API v2 (–±—É–¥—É—â–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è)
api_v2 = APIRouter(prefix="/api/v2")
# ...

app.include_router(api_v1)
app.include_router(api_v2)
```

---

## üì± UX/UI –£–ª—É—á—à–µ–Ω–∏—è

### 1. **Offline Support (PWA)**

```javascript
// frontend/sw.js (Service Worker)
const CACHE_NAME = 'telegram-mini-app-v1';
const urlsToCache = [
    '/',
    '/index.html',
    '/src/app/styles/global.css',
    '/src/app/styles/variables.css',
    // ... –¥—Ä—É–≥–∏–µ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ä–µ—Å—É—Ä—Å—ã
];

self.addEventListener('install', event => {
    event.waitUntil(
        caches.open(CACHE_NAME)
            .then(cache => cache.addAll(urlsToCache))
    );
});

self.addEventListener('fetch', event => {
    event.respondWith(
        caches.match(event.request)
            .then(response => response || fetch(event.request))
    );
});
```

```html
<!-- index.html -->
<link rel="manifest" href="/manifest.json">
<script>
if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js');
}
</script>
```

### 2. **Skeleton Screens**

```css
/* shared/ui/skeleton/skeleton.css */
.skeleton {
    background: linear-gradient(
        90deg,
        var(--bg-secondary) 25%,
        var(--bg-tertiary) 50%,
        var(--bg-secondary) 75%
    );
    background-size: 200% 100%;
    animation: loading 1.5s infinite;
}

@keyframes loading {
    0% { background-position: 200% 0; }
    100% { background-position: -200% 0; }
}

.skeleton-card {
    height: 100px;
    border-radius: 12px;
    margin-bottom: 12px;
}
```

### 3. **Pull-to-Refresh**

```javascript
// shared/lib/pull-to-refresh.js
export function enablePullToRefresh(onRefresh) {
    let startY = 0;
    let currentY = 0;
    let pulling = false;
    
    const refreshIndicator = document.createElement('div');
    refreshIndicator.className = 'pull-to-refresh-indicator';
    refreshIndicator.textContent = '‚Üì –ü–æ—Ç—è–Ω–∏—Ç–µ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è';
    document.body.prepend(refreshIndicator);
    
    document.addEventListener('touchstart', e => {
        if (window.scrollY === 0) {
            startY = e.touches[0].clientY;
            pulling = true;
        }
    });
    
    document.addEventListener('touchmove', e => {
        if (!pulling) return;
        
        currentY = e.touches[0].clientY;
        const diff = currentY - startY;
        
        if (diff > 0) {
            refreshIndicator.style.transform = `translateY(${Math.min(diff, 80)}px)`;
        }
    });
    
    document.addEventListener('touchend', async () => {
        if (!pulling) return;
        
        const diff = currentY - startY;
        
        if (diff > 80) {
            refreshIndicator.textContent = '‚ü≥ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ...';
            await onRefresh();
        }
        
        refreshIndicator.style.transform = 'translateY(0)';
        pulling = false;
    });
}
```

### 4. **Haptic Feedback**

```javascript
// shared/lib/haptic.js
export const haptic = {
    light() {
        window.Telegram?.WebApp?.HapticFeedback?.impactOccurred('light');
    },
    
    medium() {
        window.Telegram?.WebApp?.HapticFeedback?.impactOccurred('medium');
    },
    
    heavy() {
        window.Telegram?.WebApp?.HapticFeedback?.impactOccurred('heavy');
    },
    
    success() {
        window.Telegram?.WebApp?.HapticFeedback?.notificationOccurred('success');
    },
    
    error() {
        window.Telegram?.WebApp?.HapticFeedback?.notificationOccurred('error');
    },
    
    warning() {
        window.Telegram?.WebApp?.HapticFeedback?.notificationOccurred('warning');
    }
};

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
button.addEventListener('click', () => {
    haptic.light();
    // ...
});
```

---

## üîê –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å

### 1. **Input Sanitization**

```python
# requirements.txt
bleach==6.1.0

# shared/security/sanitizer.py
import bleach

def sanitize_html(text: str) -> str:
    """–û—á–∏—Å—Ç–∫–∞ HTML –æ—Ç –æ–ø–∞—Å–Ω—ã—Ö —Ç–µ–≥–æ–≤"""
    allowed_tags = ['b', 'i', 'u', 'em', 'strong']
    return bleach.clean(text, tags=allowed_tags, strip=True)

def sanitize_phone(phone: str) -> str:
    """–ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞"""
    import re
    # –£–¥–∞–ª—è–µ–º –≤—Å–µ –∫—Ä–æ–º–µ —Ü–∏—Ñ—Ä –∏ +
    phone = re.sub(r'[^\d+]', '', phone)
    return phone
```

### 2. **SQL Injection Protection**

–£–∂–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è SQLAlchemy ORM, –Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –≤–∞–ª–∏–¥–∞—Ü–∏—é:

```python
from pydantic import validator, Field

class AppointmentCreate(BaseModel):
    service_id: int = Field(..., gt=0)
    client_id: int = Field(..., gt=0)
    
    @validator('service_id', 'client_id')
    def validate_positive(cls, v):
        if v <= 0:
            raise ValueError('ID –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º')
        return v
```

### 3. **CSRF Protection**

```python
# requirements.txt
fastapi-csrf-protect==0.3.4

# api_server.py
from fastapi_csrf_protect import CsrfProtect
from fastapi_csrf_protect.exceptions import CsrfProtectError

@app.exception_handler(CsrfProtectError)
def csrf_protect_exception_handler(request, exc):
    return JSONResponse(
        status_code=403,
        content={"detail": "CSRF token validation failed"}
    )

# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ endpoints
@router.post("/appointments")
async def create_appointment(
    csrf_protect: CsrfProtect = Depends(),
    ...
):
    await csrf_protect.validate_csrf(request)
    ...
```

---

## üìä –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ –ê–ª–µ—Ä—Ç—ã

### 1. **Prometheus Metrics**

```python
# requirements.txt
prometheus-client==0.19.0

# shared/monitoring/metrics.py
from prometheus_client import Counter, Histogram, generate_latest

# –ú–µ—Ç—Ä–∏–∫–∏
http_requests_total = Counter(
    'http_requests_total',
    'Total HTTP requests',
    ['method', 'endpoint', 'status']
)

http_request_duration = Histogram(
    'http_request_duration_seconds',
    'HTTP request duration',
    ['method', 'endpoint']
)

# Middleware
@app.middleware("http")
async def metrics_middleware(request: Request, call_next):
    start_time = time.time()
    
    response = await call_next(request)
    
    duration = time.time() - start_time
    
    http_requests_total.labels(
        method=request.method,
        endpoint=request.url.path,
        status=response.status_code
    ).inc()
    
    http_request_duration.labels(
        method=request.method,
        endpoint=request.url.path
    ).observe(duration)
    
    return response

# Endpoint –¥–ª—è –º–µ—Ç—Ä–∏–∫
@app.get("/metrics")
async def metrics():
    return Response(generate_latest(), media_type="text/plain")
```

### 2. **Error Tracking (Sentry)**

```python
# requirements.txt
sentry-sdk[fastapi]==1.40.0

# api_server.py
import sentry_sdk

sentry_sdk.init(
    dsn=config.sentry_dsn,
    environment=config.environment,
    traces_sample_rate=1.0,
)
```

---

## üìù –ò—Ç–æ–≥–æ–≤—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞–º

### üî¥ –ö—Ä–∏—Ç–∏—á–Ω–æ (—Å–¥–µ–ª–∞—Ç—å –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ)
1. ‚úÖ –ò—Å–ø—Ä–∞–≤–∏—Ç—å –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –ë–î (chmod 660)
2. ‚úÖ –ù–∞—Å—Ç—Ä–æ–∏—Ç—å –º–∏–≥—Ä–∞—Ü–∏–∏ Alembic
3. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π –∑–∞–ø–∏—Å–µ–π
4. ‚úÖ –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –±–µ–∑–æ–ø–∞—Å–Ω–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ (–ø—Ä–æ–≤–µ—Ä–∫–∞ –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π)

### üü° –í–∞–∂–Ω–æ (–≤ —Ç–µ—á–µ–Ω–∏–µ –º–µ—Å—è—Ü–∞)
1. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å —Ç–µ—Å—Ç—ã (–º–∏–Ω–∏–º—É–º unit-—Ç–µ—Å—Ç—ã –¥–ª—è –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π)
2. ‚úÖ –ù–∞—Å—Ç—Ä–æ–∏—Ç—å CI/CD
3. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è —á–µ—Ä–µ–∑ Telegram Bot
4. ‚úÖ –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏ –∞–Ω–∞–ª–∏—Ç–∏–∫—É
5. ‚úÖ –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∑–∞–ø—Ä–æ—Å—ã –∫ –ë–î (eager loading)

### üü¢ –ñ–µ–ª–∞—Ç–µ–ª—å–Ω–æ (–≤ —Ç–µ—á–µ–Ω–∏–µ –∫–≤–∞—Ä—Ç–∞–ª–∞)
1. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ (Redis)
2. ‚úÖ –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø—É–±–ª–∏—á–Ω–æ–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ
3. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å —ç–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö
4. ‚úÖ –ù–∞—Å—Ç—Ä–æ–∏—Ç—å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ (Prometheus/Grafana)
5. ‚úÖ –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å PWA —Å offline support

### üîµ –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ (–ø–æ –∂–µ–ª–∞–Ω–∏—é)
1. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å –ø–æ–∏—Å–∫ –ø–æ –≤—Å–µ–º —Å—É—â–Ω–æ—Å—Ç—è–º
2. ‚úÖ –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π
3. ‚úÖ –î–æ–±–∞–≤–∏—Ç—å haptic feedback
4. ‚úÖ –ù–∞—Å—Ç—Ä–æ–∏—Ç—å error tracking (Sentry)

---

## üéØ –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–ü—Ä–æ–µ–∫—Ç –∏–º–µ–µ—Ç **–æ—Ç–ª–∏—á–Ω—É—é –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—É—é –æ—Å–Ω–æ–≤—É** –∏ —Å–ª–µ–¥—É–µ—Ç —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–º –ø—Ä–∞–∫—Ç–∏–∫–∞–º —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏. –û—Å–Ω–æ–≤–Ω—ã–µ –æ–±–ª–∞—Å—Ç–∏ –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è:

1. **–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å** - –∫—Ä–∏—Ç–∏—á–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã —Å –ø—Ä–∞–≤–∞–º–∏ –¥–æ—Å—Ç—É–ø–∞ –∫ –ë–î
2. **–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ** - –ø–æ–ª–Ω–æ–µ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ —Ç–µ—Å—Ç–æ–≤
3. **–§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å** - –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏
4. **–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥** - –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –º–µ—Ç—Ä–∏–∫ –∏ –∞–ª–µ—Ä—Ç–æ–≤
5. **UX** - –º–æ–∂–Ω–æ —É–ª—É—á—à–∏—Ç—å —Å –ø–æ–º–æ—â—å—é PWA, haptic feedback –∏ —Ç.–¥.

–ü—Ä–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π –ø—Ä–æ–µ–∫—Ç —Å—Ç–∞–Ω–µ—Ç **production-ready** –∏ —Å–º–æ–∂–µ—Ç –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞—Ç—å—Å—è –¥–ª—è –±–æ–ª—å—à–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.

---

**–ê–≤—Ç–æ—Ä –∞–Ω–∞–ª–∏–∑–∞:** AI Code Reviewer  
**–ö–æ–Ω—Ç–∞–∫—Ç:** –î–ª—è –≤–æ–ø—Ä–æ—Å–æ–≤ —Å–æ–∑–¥–∞–π—Ç–µ issue –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏
