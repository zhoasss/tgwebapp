# Логика проверки пересечений записей

## Визуальная схема

### Случай 1: Новая запись начинается во время существующей
```
Существующая: |========|
Новая:            |========|
                  ↑
              Пересечение!
```

### Случай 2: Новая запись заканчивается во время существующей
```
Существующая:     |========|
Новая:        |========|
                      ↑
                  Пересечение!
```

### Случай 3: Новая запись полностью охватывает существующую
```
Существующая:   |====|
Новая:        |==========|
              ↑        ↑
          Пересечение!
```

### Случай 4: Существующая запись полностью охватывает новую
```
Существующая: |==========|
Новая:          |====|
                ↑    ↑
            Пересечение!
```

### Случай 5: Записи не пересекаются (OK)
```
Существующая: |====|
Новая:                |====|
              ✓ Нет пересечения
```

```
Существующая:         |====|
Новая:        |====|
              ✓ Нет пересечения
```

## Примеры с реальным временем

### Пример 1: Пересечение (начало)
```
Запись A: 14:00 - 15:00 (60 мин)
Запись B: 14:30 - 15:30 (60 мин)

Временная шкала:
14:00    14:30    15:00    15:30
|-----A-----|
         |-----B-----|
         ↑
    Пересечение!

Результат: ❌ Ошибка
Сообщение: "Время пересекается с существующей записью: 14.11.2025 14:00 - 15:00"
```

### Пример 2: Пересечение (конец)
```
Запись A: 14:00 - 15:00 (60 мин)
Запись B: 13:30 - 14:30 (60 мин)

Временная шкала:
13:30    14:00    14:30    15:00
         |-----A-----|
|-----B-----|
              ↑
         Пересечение!

Результат: ❌ Ошибка
```

### Пример 3: Полное охватывание
```
Запись A: 14:00 - 15:00 (60 мин)
Запись B: 13:00 - 16:00 (180 мин)

Временная шкала:
13:00    14:00    15:00    16:00
         |--A--|
|--------B--------|
         ↑    ↑
    Пересечение!

Результат: ❌ Ошибка
```

### Пример 4: Нет пересечения (последовательные)
```
Запись A: 14:00 - 15:00 (60 мин)
Запись B: 15:00 - 16:00 (60 мин)

Временная шкала:
14:00    15:00    16:00
|--A--|
       |--B--|
       ↑
   Граница (OK)

Результат: ✅ Успешно
Примечание: Записи начинаются ровно в момент окончания предыдущей
```

### Пример 5: Нет пересечения (с промежутком)
```
Запись A: 14:00 - 15:00 (60 мин)
Запись B: 15:30 - 16:30 (60 мин)

Временная шкала:
14:00    15:00    15:30    16:30
|--A--|
              |--B--|
       ↑
   30 мин промежуток

Результат: ✅ Успешно
```

## Код проверки

### Упрощенная логика (псевдокод)
```python
def check_overlap(new_start, new_end, existing_start, existing_end):
    # Случай 1: Новая начинается во время существующей
    if existing_start <= new_start < existing_end:
        return True
    
    # Случай 2: Новая заканчивается во время существующей
    if existing_start < new_end <= existing_end:
        return True
    
    # Случай 3: Новая охватывает существующую
    if new_start <= existing_start and existing_end <= new_end:
        return True
    
    # Нет пересечения
    return False
```

### SQL запрос (SQLAlchemy)
```python
query = select(Appointment).where(
    Appointment.user_id == user_id,
    Appointment.status.in_([AppointmentStatus.PENDING, AppointmentStatus.CONFIRMED]),
    or_(
        # Случай 1: Новая начинается во время существующей
        and_(
            Appointment.appointment_date <= new_start,
            new_start < Appointment.appointment_date + duration
        ),
        # Случай 2: Новая заканчивается во время существующей
        and_(
            Appointment.appointment_date < new_end,
            new_end <= Appointment.appointment_date + duration
        ),
        # Случай 3: Новая охватывает существующую
        and_(
            new_start <= Appointment.appointment_date,
            Appointment.appointment_date + duration <= new_end
        )
    )
)
```

## Особенности реализации

### Учитываются только активные записи
```python
# Проверяются только:
- PENDING (ожидает подтверждения)
- CONFIRMED (подтверждена)

# НЕ проверяются:
- CANCELLED (отменена)
- COMPLETED (завершена)
```

### Исключение при редактировании
```python
# При редактировании записи ID=123
# исключаем её из проверки пересечений
if exclude_appointment_id:
    query = query.where(Appointment.id != exclude_appointment_id)
```

### Валидация времени
```python
# Дополнительные проверки:
1. Запись не в прошлом
2. Продолжительность > 0
3. Продолжительность <= 480 минут (8 часов)
4. Нет пересечений
```

## Примеры использования API

### Успешное создание
```bash
POST /api/appointments
{
  "service_id": 1,
  "client_id": 1,
  "appointment_date": "2025-12-01T14:00:00",
  "duration_minutes": 60
}

Response: 200 OK
{
  "id": 1,
  "appointment_date": "2025-12-01T14:00:00",
  ...
}
```

### Ошибка пересечения
```bash
POST /api/appointments
{
  "service_id": 1,
  "client_id": 2,
  "appointment_date": "2025-12-01T14:30:00",
  "duration_minutes": 60
}

Response: 400 Bad Request
{
  "detail": "Время пересекается с существующей записью: 01.12.2025 14:00 - 15:00 (Клиент: Иван)"
}
```

### Ошибка валидации
```bash
POST /api/appointments
{
  "service_id": 1,
  "client_id": 1,
  "appointment_date": "2020-01-01T14:00:00",
  "duration_minutes": 60
}

Response: 400 Bad Request
{
  "detail": "Нельзя создать запись в прошлом"
}
```

## Тестовые сценарии

### Сценарий 1: Последовательные записи
```
1. Создать запись: 14:00 - 15:00 ✅
2. Создать запись: 15:00 - 16:00 ✅
3. Создать запись: 16:00 - 17:00 ✅

Результат: Все успешно
```

### Сценарий 2: Попытка двойного бронирования
```
1. Создать запись: 14:00 - 15:00 ✅
2. Попытка: 14:00 - 15:00 ❌ (точное совпадение)
3. Попытка: 14:15 - 15:15 ❌ (пересечение)
4. Попытка: 13:45 - 14:45 ❌ (пересечение)
5. Создать запись: 15:00 - 16:00 ✅ (граница)

Результат: 2 успешно, 3 отклонено
```

### Сценарий 3: Редактирование записи
```
1. Создать запись A: 14:00 - 15:00 ✅
2. Создать запись B: 15:00 - 16:00 ✅
3. Изменить A на: 14:30 - 15:30 ❌ (пересечение с B)
4. Изменить A на: 13:00 - 14:00 ✅ (нет пересечения)

Результат: Редактирование с проверкой работает
```

## Производительность

### Оптимизации
- Используется индекс на `appointment_date`
- Фильтрация по `user_id` (индекс)
- Фильтрация по `status` (только активные)
- Ранний выход при первом найденном пересечении

### Сложность
- Временная: O(n) где n - количество активных записей пользователя
- Пространственная: O(1)

## Будущие улучшения

1. **Кэширование**
   - Кэшировать список активных записей на день
   - Инвалидация при создании/изменении/удалении

2. **Batch проверка**
   - Проверка нескольких записей за один запрос
   - Полезно для массового импорта

3. **Учет рабочих часов**
   - Проверка, что запись в рабочее время
   - Учет перерывов

4. **Буферное время**
   - Настраиваемый промежуток между записями
   - Например, 15 минут на подготовку
